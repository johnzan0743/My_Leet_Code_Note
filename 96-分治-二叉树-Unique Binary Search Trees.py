class Solution:
    def numTrees(self, n: int) -> int:
        # n: 1,2....n
        # [1,i-1],i,[i+1,n]
        # 左边的子树个数为 i-1 右边的子树为n-i 
        # 例如 1，2，3，4，5，6 （1，2，......n）
        # 3为根节点，左子树为1，2  右子树为4，5，6
        # 易得左子树个数为 i-1，右子树个数为 n-i
        # 假设f(n) = 我们有n个数字时可以构建几种搜索树
        # 易得  f(0) = 1, f(1) = 1, f(2) = f(0)*f(1) + f(1)*f(0) = 1+1 = 2
        
        # f(3) = f(0)*f(2) + f(1)*f(1) + f(2)*f(0)
        # f(4) = f(0)*(3) + f(1)*f(2) + f(2)*f(1) + f(3)*f(0)
        # 即对于以i元素为根节点，所有可能的二叉搜索树的个数为 f(j)*f(i-1-j)的和
        # j的取值范围是range(i)，前闭后开


        # 这个题其实要我们遍历两次
        # 第一次遍历从2到n+1（前闭后开），这里遍历的元素i是指以i元素为根节点的所有可能性
        # 第二次遍历从1到i+1（前闭后开），这里遍历的是笛卡尔积，即两两相乘之后求和，也即对笛卡尔积集合进行求和
        F = [0]*(n+1)
        F[0] = 1
        F[1] = 1
        for i in range(2,n+1):  
        # 此时len(F) = n-2+1 = n -1，再加上F[0],F[1]，一共有n+1个元素
        # 所以开始F要预留n+1个0
            for j in range(i):
                F[i] += F[j] * F[i-1-j]
        return F[n]